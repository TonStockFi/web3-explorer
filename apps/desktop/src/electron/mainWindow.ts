import {
    app,
    BrowserWindow,
    BrowserWindowConstructorOptions,
    clipboard,
    globalShortcut,
    ipcMain,
    nativeImage,
    screen,
    Tray,
    webContents
} from 'electron';
import contextMenu from 'electron-context-menu';
import isDev from 'electron-is-dev';
import * as fs from 'fs';
import i18n from 'i18next';
import path from 'path';
import { Cookie, CookieJar } from 'tough-cookie';
import { Message, OnAction } from '../libs/message';
import { handleBackgroundMessage } from './background';
import { CookieStore } from './cookieStorage';
import './i18n';
import { handleActionMessage } from './onAction';
import { delay } from './utils';
import { getLocalIPAddress, WebSocketServerWrapper } from './ws-server/server';

const publicDir = path.resolve(__dirname, isDev ? '../../' : '../../../', 'public');

export function t(key: string) {
    return i18n.t(key) || key;
}

let flagDev = isDev;

if (flagDev) {
    contextMenu({
        showInspectElement: true,
        showSaveImageAs: false,
        showSearchWithGoogle: false,
        showLookUpSelection: false,
        showSelectAll: false,
        labels: {
            copy: t('Copy'),
            paste: t('paste')
        }
    });
}
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const isMac = process.platform === 'darwin';
const isWin = process.platform === 'win32';

const store = new CookieStore();
const cookieJar = new CookieJar(store);
let openCvData = '';

export class MainWindow {
    static mainWindow: BrowserWindow | undefined = undefined;
    static windows: Map<string, BrowserWindow> = new Map();
    static windowsReady: Map<string, boolean> = new Map();
    static currentUrl: string = MAIN_WINDOW_WEBPACK_ENTRY;
    static tray: Tray | undefined = undefined;
    static shortcutKeys: string[] = [
        'Cmd+Shift+W',
        'CommandOrControl+F',
        'CommandOrControl+W',
        'Escape'
    ];

    static getIcon() {
        return (() => {
            switch (process.platform) {
                case 'darwin':
                    return path.join(process.cwd(), 'public', 'icon.icns');
                case 'win32':
                    return path.join(process.cwd(), 'public', 'icon.ico');
                default:
                    return '';
            }
        })();
    }
    static getOptions() {
        const icon = this.getIcon();
        return {
            darkTheme: false,
            resizable: true,
            backgroundColor: '#232323',
            icon: icon,
            frame: false,
            webPreferences: {
                allowRunningInsecureContent: false,
                experimentalFeatures: false,
                spellcheck: false,
                nodeIntegration: true,
                contextIsolation: true,
                webviewTag: true,
                preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
            }
        } as BrowserWindowConstructorOptions;
    }

    static createTray(name?: string) {
        const tray = new Tray(path.resolve(publicDir, 'tray-icon.png'));
        tray.setToolTip(name || 'Web3 Explorer');
        tray.on('click', () => {
            console.log('tray clicked');
            let win = this.windows.get('LLM');
            if (win) {
                if (win.isMinimized()) {
                    win.restore();
                }
                win.show();
                win.focus();
            }
        });
        this.tray = tray;
    }
    static getWinById(winId: string) {
        let win;
        if (winId && this.windows.get(winId)) {
            win = this.windows.get(winId);
        }
        if (winId && winId === 'main') {
            win = this.mainWindow;
        }
        return win;
    }
    static async createWindow({
        openDevTools,
        winId,
        url,
        windowOptions
    }: {
        openDevTools?: boolean;
        winId: string;
        url?: string;
        windowOptions: any;
    }) {
        let win = this.windows.get(winId);
        if (!win) {
            const { webPreferences, ...props } = this.getOptions();
            const { webPreferences: webPreferences1, ...props1 } = windowOptions;

            win = new BrowserWindow({
                ...props,
                webPreferences: {
                    ...webPreferences,
                    ...(webPreferences1 || {})
                },
                x: isDev ? 50 : undefined,
                y: isDev ? 50 : undefined,
                ...props1
            });
            this.windows.set(winId, win);
            win.on('close', (e: any) => {
                let w = this.windows.get(winId);
                if (w && winId === 'LLM') {
                    console.log('LLM window closed');
                    e.preventDefault();
                    w.hide();
                }
            });

            win.on('closed', (e: any) => {
                let w = this.windows.get(winId);
                if (w) {
                    w = undefined;
                }
                this.windowsReady.delete(winId);
                this.windows.delete(winId);
            });
            url && win.loadURL(url);
            if (winId === 'LLM') {
                this.createTray();
            }
            this.onWinEvent(win);
            this.handleShotcuts(win);
        } else {
            if (win.isMinimized()) {
                win.restore();
            }
            win.show();
            win.focus();
        }
        if (openDevTools) {
            win.webContents.openDevTools({ mode: 'detach' });
        }
        return win;
    }
    static async openMainWindow() {
        if (this.mainWindow !== undefined && this.mainWindow !== null) return this.mainWindow;
        this.mainWindow = new BrowserWindow({
            ...this.getOptions(),
            x: isDev ? 0 : undefined,
            y: isDev ? 0 : undefined,
            width: isDev ? 1280 : 1280,
            minWidth: 380,
            height: 840,
            minHeight: 840,
            titleBarStyle: 'hiddenInset',
            titleBarOverlay: false,
            trafficLightPosition: { x: 18, y: 14 },
            frame: false,
            autoHideMenuBar: true
        });

        if (flagDev) {
            const pathLoadFromLocal =
                process.platform === 'darwin' ? '/Users/ton/url.txt' : 'd:\\projects\\url.txt';
            try {
                const data = fs.readFileSync(pathLoadFromLocal, 'utf8');
                if (data) {
                    this.currentUrl = data.trim();
                }
            } catch (err) {
                console.error('Error reading file:', err);
            }
        }
        try {
            const data = fs.readFileSync(path.resolve(publicDir, 'opencv.js'), 'utf8');
            openCvData = data.trim();
        } catch (err) {
            console.error('Error reading file: opencv.js', err);
        }

        this.mainWindow.loadURL(this.currentUrl);
        // Menu.setApplicationMenu(Menu.buildFromTemplate([]));

        if (flagDev) {
            this.mainWindow.webContents.openDevTools({ mode: 'right' });
        }

        this.mainWindow.on('closed', () => {
            this.windows.forEach(win => {
                win.close();
            });
            if (this.tray) {
                this.tray.destroy();
                this.tray = undefined;
            }
            ipcMain.removeHandler('siteMessage');
            ipcMain.removeHandler('message');

            this.mainWindow = undefined;
        });
        this.handleShotcuts(this.mainWindow);
        this.onWinEvent(this.mainWindow);
        this.mainWindow.webContents.on('dom-ready', () => {
            this.mainWindow.show();
        });
        ipcMain.handle('siteMessage', (event, message: { action: string; payload: any }) => {
            try {
                return this.onSiteMessage(message, event.sender.id);
            } catch (e) {
                console.error('siteMessage error', e);
                return null;
            }
        });
        ipcMain.handle('message', async (event, message: Message) => {
            try {
                if (message.king === 'onAction') {
                    return this.handleOnActionMessage(message);
                } else {
                    return await handleBackgroundMessage(message);
                }
            } catch (e) {
                console.error('main message error', e);
                return null;
            }
        });

        this.mainWindow.webContents.session.webRequest.onBeforeSendHeaders(
            { urls: [] },
            (details, callback) => {
                cookieJar.getCookies(details.url).then(cookies => {
                    const result = cookies
                        .map(cookie => `${cookie.key}=${cookie.value}`)
                        .join('; ');

                    /* patch tg auth headers  */
                    if (details.url === 'https://oauth.telegram.org/auth/get') {
                        details.requestHeaders.origin = 'https://tonkeeper.com';
                        details.requestHeaders.referer = 'https://tonkeeper.com';
                    }

                    callback({
                        ...details,
                        requestHeaders: {
                            ...details.requestHeaders,
                            cookie: result
                        }
                    });
                });
            }
        );

        this.mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
            const setCookie = details.responseHeaders['set-cookie'] ?? [];

            const patchMercuryCors = details.url.startsWith('https://api.mercuryo.io');
            const patchTonkeeperCors = /https:\/\/(\w+\.){0,2}tonkeeper.com([?/].*)?/.test(
                details.url
            );
            const patchTgCors = details.url === 'https://oauth.telegram.org/auth/get';

            /* patch cors  */
            if (patchMercuryCors || patchTonkeeperCors || patchTgCors) {
                const corsHeader =
                    Object.keys(details.responseHeaders).find(
                        k => k.toLowerCase() === 'access-control-allow-origin'
                    ) || 'access-control-allow-origin';
                details.responseHeaders[corsHeader] = ['*'];
            }

            // Modify CSP to allow blob: scheme in connect-src
            const cspHeader = Object.keys(details.responseHeaders).find(
                k => k.toLowerCase() === 'content-security-policy'
            );

            if (
                cspHeader &&
                details.url.indexOf('google.com') === -1 &&
                details.url.indexOf('gmail.com') === -1
            ) {
                details.responseHeaders[cspHeader] = details.responseHeaders[cspHeader].map(
                    policy => {
                        // Add blob: to connect-src if not already present
                        if (!policy.includes("connect-src 'self' blob:")) {
                            return policy.replace(
                                "connect-src 'self'",
                                "connect-src 'self' blob: aptabase-ipc:"
                            );
                        }
                        return policy;
                    }
                );
            }

            Promise.all(
                setCookie.map(cookieRaw =>
                    cookieJar.setCookie(Cookie.parse(cookieRaw), details.url)
                )
            ).finally(() => {
                callback(details);
            });
        });

        this.mainWindow.webContents.session.on('select-hid-device', (event, details, callback) => {
            event.preventDefault();
            if (details.deviceList && details.deviceList.length > 0) {
                callback(details.deviceList[0].deviceId);
            }
        });

        this.mainWindow.webContents.session.setDevicePermissionHandler(details => {
            const allowedConnections = ['usb', 'hid'];
            const allowedOrigins = ['file://', 'http://localhost:3000'];
            if (
                allowedConnections.includes(details.deviceType) &&
                allowedOrigins.includes(details.origin)
            ) {
                return true;
            }
        });

        await delay(500);
        return this.mainWindow;
    }
    static onWinEvent(win: BrowserWindow) {
        win.on('enter-full-screen', () => {
            win.webContents.send('onMainMessage', {
                action: 'onFullScreen',
                payload: {
                    isFullScreen: true
                }
            });
        });

        win.on('leave-full-screen', () => {
            win.webContents.send('onMainMessage', {
                action: 'onFullScreen',
                payload: {
                    isFullScreen: false
                }
            });
        });
    }
    static handleShotcuts(win: BrowserWindow) {
        const { shortcutKeys } = this;
        win.on('blur', () => {
            let flag = false;
            [
                ...Array.from(this.windows)
                    .filter(row => !row[0].startsWith('PLAYGROUND_'))
                    .map(row => row[1]),
                this.mainWindow
            ].forEach(win => {
                if (win && win.isFocused()) {
                    flag = true;
                }
            });
            if (!flag) {
                shortcutKeys.forEach(key => {
                    globalShortcut.unregister(key);
                });
            }

            win.webContents.send('onMainMessage', {
                action: 'onBlur',
                payload: {}
            });
        });

        win.on('focus', () => {
            win.webContents.send('onMainMessage', {
                action: 'onFocus',
                payload: {}
            });
            shortcutKeys.forEach(key => {
                globalShortcut.register(key, () => {
                    [
                        ...Array.from(this.windows)
                            .filter(row => !row[0].startsWith('PLAYGROUND_'))
                            .map(row => row[1]),
                        this.mainWindow
                    ].forEach(win => {
                        if (win && win.isFocused()) {
                            win.webContents.send('onMainMessage', {
                                action: 'onShortcut',
                                payload: { key }
                            });
                        }
                    });
                });
            });
        });
    }
    static onSiteMessage(message: { action: string; payload: any }, senderId: number) {
        console.log('>> site message', message);
        if (message.action === 'isWinReady') {
            const { winId } = message.payload || {};
            const isReady = winId ? !!this.windowsReady.get(winId) : false;
            //console.log(winId,isReady,this.windowsReady.get(winId))
            return isReady;
        } else if (message.action === 'subWin') {
            const { toWinId, ...p } = message.payload || {};
            if (
                this.windows.has(toWinId) &&
                this.windowsReady.has(toWinId) &&
                this.windowsReady.get(toWinId)
            ) {
                this.windows.get(toWinId).webContents.send('onMainMessage', {
                    toWinId,
                    ...p
                });
                return true;
            } else {
                return false;
            }
        } else {
            this.mainWindow.webContents.send('siteMessage', {
                senderWebContentsId: senderId,
                message
            });
        }
    }
    static async handleOnActionMessage(message: OnAction) {
        const messageAction = message.payload.action;
        const messageValue = message.payload.value || {};

        console.log('>> onAction', messageAction);
        if (messageAction !== 'copyImageDataUrlToClipBoard') {
            console.log('>> onAction value:', messageValue);
        }
        if ('subWin' === messageAction) {
            const { toWinId, fromWinId, action, payload } = messageValue;

            if (!toWinId || !this.windows.has(toWinId) || !this.windowsReady.get(toWinId)) {
                return false;
            }
            const win = this.windows.get(toWinId)!;
            win.webContents.send('onMainMessage', {
                toWinId,
                fromWinId,
                action,
                payload
            });
            return true;
        } else if (messageAction === 'serverIsReady') {
            return WebSocketServerWrapper.serverIsReady();
        } else if (messageAction === 'stopServer') {
            return WebSocketServerWrapper.stopServer();
        } else if (messageAction === 'startServer') {
            const { port } = messageValue;
            return WebSocketServerWrapper.startServer(port || 6788);
        } else if (messageAction === 'closeApp') {
            app.quit();
        } else if (messageAction === 'closeWin') {
            const { winId } = messageValue || {};
            const win = this.getWinById(winId);
            if (win) {
                win.close();
            }
        } else if (messageAction === 'minWin') {
            const { winId } = messageValue || {};
            const win = this.getWinById(winId);
            if (win && win.isResizable) {
                win.minimize();
            }
        } else if (messageAction === 'maxWin') {
            const { winId } = messageValue || {};
            const win = this.getWinById(winId);
            if (win && win.isResizable) {
                win.setFullScreen(!win.isFullScreen());
            }
        } else if (messageAction === 'showWin') {
            const { winId } = messageValue || {};
            const win = this.getWinById(winId);
            if (win) {
                if (win.isMinimized()) {
                    win.restore();
                }
                win.show();
                win.focus();
            }
        } else if (messageAction === 'getSubWindows') {
            return {
                windows: this.windows.keys(),
                windowsIsReady: this.windowsReady.keys()
            };
        } else if (messageAction === 'regShortcutKeys') {
            const { keys } = messageValue || {};
            if (keys && keys.length > 0) {
                this.shortcutKeys = keys;
            }
        } else if (messageAction === 'copyImageDataUrlToClipBoard') {
            const { base64Data } = messageValue || {};
            if (base64Data) {
                try {
                    const image = nativeImage.createFromDataURL(base64Data);
                    clipboard.writeImage(image);
                    console.log('Image copied to clipboard successfully in Electron!');
                } catch (error) {
                    console.error('Failed to copy image to clipboard:', error);
                }
            }
        } else if (messageAction === 'getBounds') {
            const { winId } = messageValue || {};
            const win = this.getWinById(winId||"main");
            if(win){
                return win.getBounds();
            }
        } else if (messageAction === 'getTrayBounds') {
            return this.tray ? this.tray.getBounds() : null;
        } else if (messageAction === 'setBounds') {
            const { winId, bounds, animate } = messageValue || {};
            const win = this.getWinById(winId||"main");
            if(win){
                return win.setBounds(bounds, animate);
            }
            return false
        } else if ('winReady' === messageAction) {
            const { winId } = messageValue;
            this.windowsReady.set(winId, true);
        } else if ('isWinReady' === messageAction) {
            const { winId } = messageValue;
            return !!this.windowsReady.get(winId);
        } else if ('isWinOpen' === messageAction) {
            const { winId } = messageValue;
            if (this.windows.has(winId)) {
                return this.windows.get(winId).isVisible();
            } else {
                return false;
            }
        } else if ('isWinExsits' === messageAction) {
            const { winId } = messageValue;
            return this.windows.has(winId);
        } else if ('main' === messageAction) {
            this.mainWindow.webContents.send(
                'onMainMessage',
                messageValue as {
                    action: string;
                    payload: any;
                    fromWinId?: string;
                    toWinId?: string;
                }
            );
        } else if ('mainOpenDevTools' === messageAction) {
            this.mainWindow.webContents.openDevTools();
        } else if ('openWindow' === messageAction) {
            await MainWindow.createWindow(messageValue);
        } else if ('getOpenCvData' === messageAction) {
            return openCvData;
        } else if (messageAction === 'sendToSite') {
            const wc = webContents.fromId(message.payload.webContentsId! as number);
            wc.send(
                'render',
                messageValue as {
                    action: string;
                    payload: any;
                }
            );
        } else if (messageAction === 'getEnv') {
            const sessionPath = this.mainWindow.webContents.session.getStoragePath();
            const { workAreaSize, workArea } = screen.getPrimaryDisplay();
            const bounds = this.mainWindow.getBounds();
            const isFullScreen = this.mainWindow.isFullScreen();
            screen.getCursorScreenPoint;
            return {
                bounds,
                version: app.getVersion(),
                sessionPath,
                workAreaSize,
                workArea,
                dirname: __dirname,
                ip: getLocalIPAddress(),
                isDev: flagDev,
                isMac,
                isWin,
                isFullScreen
            };
        } else {
            return await handleActionMessage(message);
        }
    }
    static getCurrentUrl() {
        return this.currentUrl;
    }

    static async bringToFront() {
        if (process.platform === 'win32') {
            if (this.mainWindow) {
                if (this.mainWindow.isMinimized()) this.mainWindow.restore();
            } else {
                await this.openMainWindow();
            }

            this.mainWindow.setAlwaysOnTop(true);
            this.mainWindow.focus();
            this.mainWindow.setAlwaysOnTop(false);
        } else {
            await this.openMainWindow();
            //this.mainWindow.show();
        }

        return this.mainWindow;
    }
}
